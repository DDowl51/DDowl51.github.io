<!DOCTYPE html>
<html>
  <head>
    <style>
      canvas {
        background: #000;
        width: 100%;
        height: 100vh;
        touch-action: none;
      }
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      let width = (canvas.width = window.innerWidth);
      let height = (canvas.height = window.innerHeight);

      window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      });

      class Particle {
        constructor(x, y, isFirework, hue) {
          this.x = x;
          this.y = y;
          this.isFirework = isFirework;
          this.hue = hue;
          this.alpha = 1;
          this.acceleration = 0.95;
          this.radius = isFirework ? 2 : Math.random() * 2;

          if (isFirework) {
            this.pathIndex = 0;
            this.speed = 4;
          } else {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5;
            this.vx = Math.cos(angle) * speed * 2; // 增强爆炸速度
            this.vy = Math.sin(angle) * speed * 2;
          }
        }

        update() {
          if (!this.isFirework) {
            this.vx *= this.acceleration;
            this.vy *= this.acceleration;
            this.vy += 0.1;
            this.alpha -= 0.005; // 减缓消失速度

            this.x += this.vx;
            this.y += this.vy;
          }
        }

        draw() {
          ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      class Firework {
        constructor(path, isRandom) {
          this.particles = [];
          this.path = [...path];
          this.isRandom = isRandom;
          this.mainHue = Math.random() * 360;
          this.exploded = false;
          this.create();
        }

        create() {
          const start = this.path[0];
          const firework = new Particle(start.x, start.y, true, this.mainHue);
          firework.path = this.path;
          this.particles.push(firework);
        }

        explode() {
          if (this.exploded) return; // 防止重复爆炸
          const pos = this.particles[0];

          // 生成更多爆炸粒子
          for (let i = 0; i < 500; i++) {
            const hue = this.mainHue + (Math.random() * 60 - 30);
            const p = new Particle(pos.x, pos.y, false, hue % 360);
            this.particles.push(p);
          }
          this.exploded = true;
          this.particles.shift();
        }

        update() {
          this.particles.forEach((p, i) => {
            if (p.isFirework && !this.exploded) {
              // 路径跟随
              if (p.pathIndex < p.path.length - 1) {
                const nextPoint = p.path[p.pathIndex + 1];
                const dx = nextPoint.x - p.x;
                const dy = nextPoint.y - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > p.speed) {
                  p.x += (dx / distance) * p.speed;
                  p.y += (dy / distance) * p.speed;
                } else {
                  p.x = nextPoint.x;
                  p.y = nextPoint.y;
                  p.pathIndex++;
                }
              } else {
                this.explode();
              }

              // 边缘检测
              if (
                this.isRandom &&
                (p.x < 50 || p.x > width - 50 || p.y < 50 || p.y > height - 50)
              ) {
                this.explode();
              }
            }

            p.update();
            if (p.alpha <= 0) this.particles.splice(i, 1);
          });
        }

        draw() {
          this.particles.forEach(p => p.draw());
        }
      }

      // 系统状态
      const fireworks = [];
      let currentPath = [];
      let isDrawing = false;

      // 输入处理
      function handleInputStart(e) {
        e.preventDefault();
        isDrawing = true;
        currentPath = [getPosition(e)];
      }

      function handleInputMove(e) {
        if (!isDrawing) return;
        e.preventDefault();
        currentPath.push(getPosition(e));
      }

      function handleInputEnd(e) {
        e.preventDefault();
        isDrawing = false;

        // 确保总能获取到有效坐标
        const pos =
          currentPath.length > 0
            ? currentPath[currentPath.length - 1]
            : getPosition(e);

        // 调整触发阈值
        if (currentPath.length < 3) {
          // 降低阈值
          const angle = Math.random() * Math.PI * 2;
          const distance = 300;
          const endPoint = {
            x: pos.x + Math.cos(angle) * distance,
            y: pos.y + Math.sin(angle) * distance,
          };
          fireworks.push(new Firework([pos, endPoint], true));
        } else {
          fireworks.push(new Firework(currentPath, false));
        }
      }

      function getPosition(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.touches && e.touches.length > 0) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
          clientX = e.changedTouches[0].clientX;
          clientY = e.changedTouches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        return {
          x: clientX - rect.left,
          y: clientY - rect.top,
        };
      }

      // 事件监听
      canvas.addEventListener('touchstart', handleInputStart);
      canvas.addEventListener('touchmove', handleInputMove);
      canvas.addEventListener('touchend', handleInputEnd);

      canvas.addEventListener('mousedown', handleInputStart);
      canvas.addEventListener('mousemove', handleInputMove);
      canvas.addEventListener('mouseup', handleInputEnd);

      // 动画循环
      function animate() {
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(0, 0, width, height);

        if (isDrawing && currentPath.length > 1) {
          ctx.beginPath();
          ctx.strokeStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
          ctx.lineWidth = 2;
          ctx.moveTo(currentPath[0].x, currentPath[0].y);
          currentPath.forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        }

        fireworks.forEach((firework, i) => {
          firework.update();
          firework.draw();
          if (firework.particles.length === 0) {
            fireworks.splice(i, 1);
          }
        });

        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>

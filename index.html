<!DOCTYPE html>
<html>
  <head>
    <style>
      canvas {
        background: #000;
        width: 100%;
        height: 100vh;
        touch-action: none;
      }
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      let width = (canvas.width = window.innerWidth);
      let height = (canvas.height = window.innerHeight);

      // 窗口大小变化时重置画布
      window.addEventListener('resize', () => {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      });

      class Particle {
        constructor(x, y, isFirework, hue) {
          this.x = x;
          this.y = y;
          this.isFirework = isFirework;
          this.hue = hue;
          this.alpha = 1;
          this.acceleration = 0.95;
          this.radius = isFirework ? 2 : Math.random() * 2;

          if (isFirework) {
            this.targetY = y - (Math.random() * height) / 2;
            this.speed = -Math.sqrt(0.2 * (y - this.targetY));
            this.vx = Math.random() * 2 - 1;
            this.vy = -Math.sqrt(0.2 * (y - this.targetY));
          } else {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
          }
        }

        update() {
          if (!this.isFirework) {
            this.vx *= this.acceleration;
            this.vy *= this.acceleration;
            this.vy += 0.15; // 重力
            this.alpha -= 0.01;
          } else {
            this.vy += 0.008;
          }
          this.x += this.vx;
          this.y += this.vy;
        }

        draw() {
          ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      class Firework {
        constructor(startX, startY, targetX, targetY, hue) {
          this.particles = [];
          this.hue = hue;
          this.startX = startX;
          this.startY = startY;
          this.targetX = targetX;
          this.targetY = targetY;
          this.create();
        }

        create() {
          const angle = Math.atan2(
            this.targetY - this.startY,
            this.targetX - this.startX
          );
          const distance = Math.hypot(
            this.targetX - this.startX,
            this.targetY - this.startY
          );
          const speed = Math.sqrt(distance * 0.1);

          const firework = new Particle(
            this.startX,
            this.startY,
            true,
            this.hue
          );
          firework.vx = Math.cos(angle) * speed;
          firework.vy = Math.sin(angle) * speed;

          this.particles.push(firework);
        }

        explode() {
          for (let i = 0; i < 200; i++) {
            const p = new Particle(
              this.particles[0].x,
              this.particles[0].y,
              false,
              this.hue
            );
            this.particles.push(p);
          }
        }

        update() {
          this.particles.forEach((p, i) => {
            p.update();
            if (p.alpha <= 0) {
              this.particles.splice(i, 1);
            }
          });
        }

        draw() {
          this.particles.forEach(p => p.draw());
        }
      }

      // 烟花管理
      const fireworks = [];
      let currentPath = [];
      let isDrawing = false;
      let hue = 120;

      // 输入处理
      function startDraw(e) {
        isDrawing = true;
        currentPath = [];
        const pos = getPosition(e);
        currentPath.push({ x: pos.x, y: pos.y });
      }

      function draw(e) {
        if (!isDrawing) return;
        const pos = getPosition(e);
        currentPath.push({ x: pos.x, y: pos.y });
      }

      function endDraw(e) {
        isDrawing = false;
        const pos = getPosition(e);

        if (currentPath.length < 2) {
          // 点击事件
          const angle = -Math.random() * Math.PI;
          const distance = 50 + Math.random() * 150;
          const tx = pos.x + Math.cos(angle) * distance;
          const ty = pos.y + Math.sin(angle) * distance;
          fireworks.push(
            new Firework(pos.x, pos.y, tx, ty, (hue = Math.random() * 360))
          );
        } else {
          // 滑动轨迹
          const start = currentPath[0];
          const end = currentPath[currentPath.length - 1];
          fireworks.push(
            new Firework(
              start.x,
              start.y,
              end.x,
              end.y,
              (hue = Math.random() * 360)
            )
          );
        }
      }

      function getPosition(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches) {
          return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top,
          };
        }
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      // 事件监听
      canvas.addEventListener('mousedown', startDraw);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', endDraw);

      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        startDraw(e);
      });
      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        draw(e);
      });
      canvas.addEventListener('touchend', e => {
        e.preventDefault();
        endDraw(e);
      });

      // 动画循环
      function animate() {
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(0, 0, width, height);

        fireworks.forEach((firework, i) => {
          if (firework.particles.length === 0) return;
          if (firework.particles[0].isFirework) {
            if (firework.particles[0].vy >= 0) {
              firework.explode();
              firework.particles.shift();
            }
          }
          firework.update();
          firework.draw();

          if (firework.particles.length === 0) {
            fireworks.splice(i, 1);
          }
        });

        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
